re 正则表达式
########################

    有些人面临一个问题时会想：“我知道，我将使用正则表达式来解决这个问题。”这会让他们面临的问题变成了两个。
    -- Jamie Zawinski

正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

模块 re 提供了对正则表达式的支持，在 Python 中使用正则表达式只需两个步骤，如下：

.. highlight:: none

::

    >>>  import re
    >>>  nu = re.search(r'\d{3}-\d{3,4}-\d{4}', 'My number is 400-055-2818.')
    >>>  nu.group(0)
    400-055-2818

常用操作符
************************

操作符就是上边定义中指出的“事先定义好的一些特定字符”，它们具有特殊的含义。如果在匹配时需要使用字符原本的含义，需要用 ``\`` 转义字符含义。

=======   ====================   ====================
操作符      含义                   匹配结果
=======   ====================   ====================
\.          任何单个字符
[]         单个字符集范围           [ac] 匹配 a 或 c；[a‐z] 匹配 a 至 z 中的单个字符
[^]        非单字符集范围           [^ab] 匹配非 a 或非 b 的单个字符
\*          零次或无限次             abc* 匹配 ab、abc、abcc、abccc 等
\+          一次或无限次             abc+ 匹配 abc、abcc、abccc 等
\?          零次或一次               abc? 匹配 ab、abc
\|          左右任意一个             abc|def 匹配 abc 或 def
{m}        m 次                    ab{2}c 匹配 abbc
{m,n}      m 至 n 次               ab{1,4}c 匹配 abc、abbc、abbbc、abbbbc
\^          字符串开头               ^abc 匹配以 abc 开头的字符串 abc...
\$          字符串结尾               abc$ 匹配以 abc 结尾的字符串 ...abc
()         分组                     (abc) 匹配 abc，(abc|def) 匹配 abc 或 def
\\d         数字                    等价于 [0‐9]
\\D         非数字                  等价于 [^0-9]
\\w         单词字符                 等价于 [A‐Za‐z0‐9_]
\\W         非单词字符               等价于 [^A‐Za‐z0‐9_]
\\s 	      任意空白符               等价于 [ \\f\\n\\r\\t\\v] 包括空格、制表符、换页符等
\\S 	      非任意空白符             除空格、制表符和换行符以外的任何字符
=======   ====================   ====================

常用方法
************************

==================   ==================
方法                    描述
==================   ==================
`re.findall()`_          搜索字符串，返回列表类型
`re.finditer()`_         搜索字符串，返回匹配结果的迭代类型，每个迭代元素是 matche 对象
`re.match()`_            从字符串的开始位置起匹配正则表达式，返回 matche 对象
`re.search()`_           在字符串中搜索匹配正则表达式的第一个位置，返回 matche 对象
`re.split()`_            将一个字符串按照正则表达式匹配结果进行分割，返回列表类型
`re.sub()`_              在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串
==================   ==================

.. _`re.findall()`:

re.findall(pattern, string, flags=0)
=========================================================

对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表。空匹配也会包含在结果里。

::

    >>> re.findall(r'\d{3}', '北京区号：010；上海区号：021；保定区号：0312')
    ['010', '021', '031']

    >>> re.findall(r'\d{3,4}', '北京区号：010；上海区号：021；保定区号：0312')
    ['010', '021', '0312']

    >>> re.findall(r'(\：)(\d{3,4})', string)
    [('：', '010'), ('：', '021'), ('：', '0312')]

.. _`re.finditer()`:

re.finditer(pattern, string, flags=0)
=========================================================

pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 matche 对象 。 string 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。

.. _`re.match()`:

re.match(pattern, string, flags=0)
============================================

如果 string 开始的 0 或者多个字符匹配到了正则表达式样式，就返回一个相应的 matche 对象。如果没有匹配，就返回 ``None`` ；注意它跟零长度匹配是不同的。

.. note::

    即便是 MULTILINE 多行模式， re.match() 也只匹配字符串的开始位置，而不匹配每行开始。

.. _`re.search()`:

re.search(pattern, string, flags=0)
============================================

扫描整个字符串找到匹配样式的第一个位置，并返回一个相应的 matche 对象。如果没有匹配，就返回一个 ``None`` ； 注意这和找到一个零长度匹配是不同的。

.. _`re.split()`:

re.split(pattern, string, maxsplit=0, flags=0)
=========================================================

用 pattern 分开 string 。 如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 maxsplit 非零，最多进行 maxsplit 次分隔，剩下的字符全部返回到列表的最后一个元素。

.. _`re.sub()`:

re.sub(pattern, repl, string, count=0, flags=0)
=========================================================

返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串。 如果样式没有找到，则不加改变地返回 string。 repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，\n 会被转换为一个换行符，\r 会被转换为一个回车附，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 \& 会保持原样。 向后引用像是 \6 会用样式中第 6 组所匹配到的子字符串来替换。 例如:

re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
       r'static PyObject*\npy_\1(void)\n{',
       'def myfunc():')

如果 repl 是一个函数，那它会对每个非重复的 pattern 的情况调用。这个函数只能有一个 匹配对象 参数，并返回一个替换后的字符串。比如

def dashrepl(matchobj):
    if matchobj.group(0) == '-': return ' '
    else: return '-'
re.sub('-{1,2}', dashrepl, 'pro----gram-files')

re.sub(r'\sAND\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE)


样式可以是一个字符串或者一个 样式对象 。

可选参数 count 是要替换的最大次数；count 必须是非负整数。如果忽略这个参数，或者设置为0，所有的匹配都会被替换。空匹配只在不相临连续的情况被更替，所以 sub('x*', '-', 'abxd') 返回 '-a-b--d-' 。

在字符串类型的 repl 参数里，如上所述的转义和向后引用中，\g<name> 会使用命名组合 name，（在 (?P<name>…) 语法中定义） \g<number> 会使用数字组；\g<2> 就是 \2，但它避免了二义性，如 \g<2>0。 \20 就会被解释为组20，而不是组2后面跟随一个字符 '0'。向后引用 \g<0> 把 pattern 作为一整个组进行引用。


在 Python 中使用正则表达式有几个步骤，但每一步都相当简单。

1. 用 import re 导入正则表达式模块。
2. 用 re.compile() 函数创建一个 Regex 对象（记得使用原始字符串）。
3. 向 Regex 对象的 search() 方法传入想查找的字符串。它返回一个 Match 对象。
4. 调用 Match 对象的 group() 方法，返回实际匹配文本的字符串。

::

    >>>  import re
    >>>  phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
    >>>  mo = phoneNumRegex.search('My number is 415-555-4242.')
    >>>  print('Phone number found: ' + mo.group())
    Phone number found: 415-555-4242

贪心和非贪心匹配
***********************

在字符串 'HaHaHaHaHa' 中，因为 (Ha){3,5} 可以匹配 3 个、4 个或 5 个实例，你可能会想，为什么在前面花括号的例子中，Match 对象的 group() 调用会返回 'HaHaHaHaHa'，而不是更短的可能结果。毕竟，'HaHaHa' 和 'HaHaHaHa' 也能够有效地匹配正则表达式 (Ha){3,5}。

Python 的正则表达式默认是“贪心”的，这表示在有二义的情况下，它们会尽可能匹配最长的字符串。花括号的“非贪心”版本匹配尽可能最短的字符串，即在结束的花括号后跟着一个问号。

在交互式环境中输入以下代码，注意在查找相同字符串时，花括号的贪心形式和非贪心形式之间的区别：

::

   >>>  greedyHaRegex = re.compile(r'(Ha){3,5}')
   >>>  mo1 = greedyHaRegex.search('HaHaHaHaHa')
   >>>  mo1.group()
   'HaHaHaHaHa'

   >>>  nongreedyHaRegex = re.compile(r'(Ha){3,5}?')
   >>>  mo2 = nongreedyHaRegex.search('HaHaHaHaHa')
   >>>  mo2.group()
   'HaHaHa'

请注意，问号在正则表达式中可能有两种含义：声明非贪心匹配或表示可选的分组。这两种含义是完全无关的。

编译正则表达式
***********************

正则表达式被编译成模式对象，模式对象具有各种操作的方法，例如搜索模式匹配或执行字符串替换。

re.compile() 也接受一个可选的 flags 参数，用于启用各种特殊功能和语法变体。 我们稍后将介绍可用的设置，但现在只需一个例子
>>>

>>> p = re.compile('ab*', re.IGNORECASE)

正则作为字符串传递给 re.compile() 。 正则被处理为字符串，因为正则表达式不是核心Python语言的一部分，并且没有创建用于表达它们的特殊语法。 （有些应用程序根本不需要正则，因此不需要通过包含它们来扩展语言规范。）相反，re 模块只是Python附带的C扩展模块，就类似于 socket 或 zlib 模块。

将正则放在字符串中可以使 Python 语言更简单，但有一个缺点是下一节的主题。


re.compile(pattern, flags=0)

将正则表达式的样式编译为一个正则表达式对象（正则对象），可以用于匹配，通过这个对象的方法 match()，search() 以及其他如下描述。

这个表达式的行为可以通过指定标记的值来改变。值可以是以下任意变量，可以通过位的 OR 操作来结合（| 操作符）。

序列

prog = re.compile(pattern)
result = prog.match(string)

等价于

result = re.match(pattern, string)

如果需要多次使用这个正则表达式的话，使用 re.compile() 和保存这个正则对象以便复用，可以让程序更加高效。

.. note::

    通过 re.compile() 编译后的样式，和模块级的函数会被缓存，所以少数的正则表达式使用无需考虑编译的问题。




- 正则表达式 HOWTO https://docs.python.org/zh-cn/3/howto/regex.html
- 正则表达式操作 https://docs.python.org/zh-cn/3/library/re.html?highlight=re#module-re
