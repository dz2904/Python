生成器
#######################

如果使用 yield 语句，可以让函数生成一个结果序列，而不仅仅是一个值，例如：

.. highlight:: none

::

    def countdown(n):
        print "Counting down!"
        while n > 0:
             yield n       # 生成一个值（n）
             n -= 1

任何使用 yield 的函数都称为生成器。调用生成器函数将创建一个对象，该对象通过连续调用 ``__next__()`` 方法生成一系列的结果，例如：

::

    >>> c = countdown(5)
    >>> c.next()
    Counting down!
    5
    >>> c.next()
    4
    >>> c.next()
    3
    >>>

``__next__()`` 调用使生成器函数一直运行，到下一条 yield 语句为止。此时 ``__next__()`` 将返回传递给 yield 的值，而且函数将暂时中止执行。再次调用 ``__next__()`` 时，函数将继续执行 yield 之后的语句。此过程持续到函数返回为止。

通常不会像上面这样手动调用 ``__next__()`` ，而是会使用一个 for 循环，例如：

::

    >>> for i in countdown(5):
    ...     print i,
    Counting down!
    5 4 3 2 1
    >>>

生成器是编写基于处理管道、流或数据流程序的一种极其强大的方式。例如，下面的生成器函数模拟了常用于监控日志文件的 ``UNIX tail –f`` 命令的行为：

::

    # tail一个文件（如 tail -f）
    import time
    def tail(f):
        f.seek(0,2)     # 移动到 EOF
        while True:
            line = f.readline()    # 尝试读取一个新的文本行
            if not line:           # 如果没有内容，暂时休眠并再次尝试
                 time.sleep(0.1)
                 continue
            yield line

下面的生成器用于在很多行中查找特定的子字符串：

::

    def grep(lines, searchtext):
        for line in lines:
            if searchtext in line: yield line

下面的例子将以上两个生成器合并在一起，创建了一个简单的处理管道：

::

    # UNIX "tail –f | grep python" 命令的 python 实现
    wwwlog = tail(open("access-log"))
    pylines = grep(wwwlog,"python")
    for line in pylines:
        print line,

生成器的微妙之处在于，它经常和其他可迭代的对象（如列表或文件）混合在一起。特别是在编写如 for item in s 这样的语句时，s 可以代表一个列表、文件的各行、生成器函数的结果，或者支持迭代的其他任何对象。能够在 s 中插入不同对象，为创建可扩展的程序提供了一个强大的工具。

协程
#######################

通常，函数运行时要使用单一的一组输入参数。但是，函数也可以编写成一个任务程序， 用来处理发送给它的一系列输入。这类函数被称为协程，它是通过将 yield 语句作为表达式(yield)的形式创建的，如下所示：

.. highlight:: none

::

    def print_matches(matchtext)：
        print "Looking for",matchtext
        while True:
             line = (yield)    # 获得一行文本
             if matchtext in  line:
                 print line

要使用这个函数，首先要调用它，向前执行到第一条(yield)语句，然后使用 ``send()`` 给它发送数据，例如：

::

    >>> matcher = print_matches("python")
    >>> matcher.next()     # 向前执行到第一条(yield)语句
    Looking for python
    >>> matcher.send("Hello World")
    >>> matcher.send("python is cool")
    python is cool
    >>> matcher.send("yow!")
    >>> matcher.close()    # matcher 函数调用结束
    >>>

使用 send() 为协程发送某个值之前，协程会暂时中止。发送值之后，协程中的(yield)表达式将返回这个值，而接下来的语句将会处理它。处理直到遇到下一个(yield)表达式才会结束，这时函数将暂时中止。正如上一个例子所示，这个过程将会继续下去，直到协程函数返回或者调用它的 close() 方法为止。

基于生产者—消费者模型（即程序的一部分生成的数据会被程序的另一部分使用）编写并发程序时，协程十分有用。在这种模型中，协程代表了数据的一个消费者。下面给出了一起使用生成器和协程的一个例子：

::

    # 一组匹配器协程
    matchers = [
        print_matches("python"),
        print_matches("guido"),
        print_matches("jython")
    ]
    # 通过调用 next() 准备所有的匹配器
    for m in matchers: m.next()

    # 将一个活跃的日志文件传递给所有的匹配器。注意，为保证运行正常，
    # 必须有一台 Web 服务器持续将数据写入日志
    wwwlog = tail(open("access-log"))
    for line in wwwlog:
        for m in matchers:
            m.send(line)        # 将数据发送到每个匹配器协程中
