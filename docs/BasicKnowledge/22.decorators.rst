装饰器 @
#######################

装饰器是一个函数，其主要用途是包装另一个函数或类。这种包装的首要目的是光明正大地修改或增强被包装对象的行为。语法上使用 特殊符号 ``@`` 表示装饰器，如下所示：

.. highlight:: none

::

    @trace
    def square(x):
    　　 return x*x

上面的代码是下面代码的简化：

::

    def square(x):
    　　return x*x
    square = trace(square)

这个例子中定义了函数 square()。但在定义之后，函数对象本身就立即被传递给函数 trace()，后者返回一个对象替代原始的 square。现在，让我们看一下 trace 的实现，从而解释这样做的用处：

::

    enable_tracing = True
    if enable_tracing:
    　　debug_log = open("debug.log","w")

    def trace(func):
    　　if enable_tracing:
    　　　　def callf(*args,**kwargs):
    　　　　　　debug_log.write("Calling %s: %s, %s\n" %
    　　　　　　　　　　　　　　 (func.__name__, args, kwargs))
    　　　　　　r = func(*args,**kwargs)
    　　　　　　debug_log.write("%s returned %s\n" % (func.__name, r))
    　　　　　　return r
    　　　　return callf
    　　else:
    　　　　return func

在这段代码中，trace() 创建了一个包装器函数，它会写入一些调试输出，然后调用原始函数对象。因此如果调用 square() 函数，看到的将是包装器中 write() 方法的输出。trace() 函数返回的函数 callf 是一个闭包，用于替换原始的函数。关于这种实现的一个有趣方面是，跟踪功能本身只能像上面这样使用全局变量 enable_tracing 来启用。如果把这个变量置为 False，trace() 装饰器只是返回未修改的原始函数。因此，禁用跟踪时，使用装饰器不会增加性能负担。

使用装饰器时，它们必须出现在函数或类定义之前的单独行上。可以同时使用多个装饰器，例如：

::

    @foo
    @bar
    @spam
    def grok(x):
    　　pass

在这个例子中，装饰器将按照它们出现的先后顺序应用，结果等同于：

::

    def grok(x):
    　　pass
    grok = foo(bar(spam(grok)))

装饰器也可以接受参数，例如：

::

    @eventhandler('BUTTON')
    def handle_button(msg):
    　　 ...
    @eventhandler('RESET')
    def handle_reset(msg):
    　　 ...

如果提供参数，装饰器的语义如下所示：

::

    def handle_button(msg):
    　　 ...
    temp = eventhandler('BUTTON')　　　　　　# 使用提供的参数调用装饰器
    handle_button = temp(handle_button)　　 # 调用装饰器返回的函数

在这个例子中，装饰器函数只接受带有 ``@`` 描述符的参数。它接着返回一个函数，这个函数在调用的时候以一个函数作为参数。下面举一个例子：

::

    # 事件处理程序装饰器
    event_handlers = { }
    def eventhandler(event):
    　　 def register_function(f):
    　　　　　event_handlers[event] = f
    　　　　　return f
    　　 return register_function

装饰器也可以应用于类定义，例如：

::

    @foo
    class Bar(object):
    　　def __init__(self,x):
    　　　　self.x = x
    　　def spam(self):
    　　　　statements

对于类装饰器，应该让装饰器函数始终返回类对象作为结果。需要使用原始类定义的代码可能要直接引用类成员，如 Bar.spam。如果装饰器函数 foo() 返回一个函数，这种引用就是不正确的。

装饰器与函数其他方面的交互行为（如递归、文档字符串和函数属性）有些怪异。本章稍后将会讨论这些问题。

装饰器中的文档字符串
***********************

当函数中使用装饰器时，要注意使用装饰器包装函数可能会破坏与文档字符串相关的帮助功能。例如，考虑以下代码：

::

    def wrap(func):
    　　call(*args,**kwargs):
    　　　　return func(*args,**kwargs)
    　　return call
    @wrap
    def factorial(n):
    　　"""Computes n factorial."""
    　　...

如果用户请求这个版本的 factorial() 函数的帮助，将会看到一种相当诡异的解释：

::

    >>> help(factorial)
    Help on function call in module __main__:

    call(*args, **kwargs)
    (END)
    >>>

这个问题的解决办法是编写函数时使用 functools 模块提供了函数 wraps，用于自动复制这些属性。显而易见，它也是一个装饰器：

::

    from functools import wraps
    def wrap(func):
    　　@wraps(func)
    　　call(*args,**kwargs):
    　　　　return func(*args,**kwargs)
    　　return call

functools 模块中定义的 ``@wraps(func)`` 装饰器可以将属性从 func 传递给要定义的包装器函数。


