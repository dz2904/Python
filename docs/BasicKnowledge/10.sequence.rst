序列
#######################

Python 内置了多种序列，其中最常用的是：列表、元组和字符串（字符串就是由字符组成的序列）。

列表和元组的主要不同在于，列表是可以修改的，而元组不可以修改。在你自己编写程序时，几乎所有情况下都可使用列表来代替元组，一种例外情况是将元组用作字典的键。

Python 支持一种数据结构的基本概念，名为容器（container），容器基本上就是可包含其他对象的对象。有三种主要的容器：序列（如列表和元组）、映射（如字典）和集合（set）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。

通用的序列操作
***********************

有几种操作适用于所有序列，包括索引、切片、相加、相乘和成员资格检查。另外，Python 还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。

索引
=======================

序列中的所有元素都有编号（从 0 开始递增），这称为索引（indexing），你可使用索引来获取元素。这种索引方式适用于所有序列。当你使用负数索引时，Python 将从右（即从最后一个元素）开始往左数，因此 -1 是最后一个元素的位置。你可像下面这样来访问各个元素：

.. highlight:: none

::

    >>> greeting = 'Hello'

    >>> greeting[0]
    'H'

    >>> greeting[-1]
    'o'

对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作，无需先将其赋给变量。这与先赋给变量再对变量执行索引操作的效果是一样的。如果函数调用返回一个序列，可直接对其执行索引操作。

::

    >>> 'Hello'[1]
    'e'

    >>> fourth = input('Year: ')[3]
    Year: 2005
    >>> fourth
    '5'

切片
=======================

除使用索引来访问单个元素外，还可使用切片（slicing）来访问特定范围内的元素。切片适用于提取序列的一部分，其中的编号非常重要，第一个索引指定的元素包含在切片内，但第二个索引指定的元素不包含在切片内。请看下面的示例：

::

    >>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> numbers[3:6]
    [4, 5, 6]
    >>> numbers[3:-2]
    [4, 5, 6, 7, 8]
    >>> numbers[0:1]
    [1]

绝妙的简写
-----------------------

假设你要截取上述数字列表中的最后三个元素，你可以截取到第 11 个元素，虽然它并不存在，但确实能够截取最后三个元素。

::

    >>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> numbers[7:10]
    [8, 9, 10]

如果使用负数索引会怎么样呢？索引 -1 无法包含最后一个元素。如果使用索引0，即到达列表末尾后再前进一步所处的位置，结果将如何呢？

::

    >>> numbers[-3:-1]
    [8, 9]

    >>> numbers[-3:0]
    []

结果并不是你想要的。事实上，执行切片操作时，如果第一个索引指定的元素位于第二个索引指定的元素后面（如上例），结果就为空序列。
我们可以用一种简写实现截取最后三个元素的操作。如果切片结束于序列末尾，可省略第二个索引。

::

    >>> numbers[-3:]
    [8, 9, 10]

    # 如果切片始于序列开头，也可省略第一个索引。
    >>>> numbers[:3]
    >[1, 2, 3]

    # 要复制整个序列，可将两个索引都省略。
    >>> numbers[:]
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

更大的步长
-----------------------

执行切片操作时，你显式或隐式地指定起点和终点，但通常会省略另一个参数，即步长。在普通切片中，步长为 1。这意味着从一个元素移到下一个元素，因此切片包含起点和终点之间的所有元素。还可以指定步长，如果指定的步长大于 1，将跳过一些元素。例如：步长为 2 时，将从起点和终点之间每隔一个元素提取一个元素。

::

    >>> numbers[0:10:1]
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    >>> numbers[0:10:2]
    [1, 3, 5, 7, 9]

    >>> numbers[3:6:3]
    [4]

    >>> numbers[::4]
    [1, 5, 9]

当然，步长不能为 0，否则无法向前移动，但可以为负数，即从右向左提取元素。在这种情况下，要正确地提取颇费思量。如你所见，第一个索引依然包含在内，而第二个索引不包含在内。步长为负数时，第一个索引必须比第二个索引大。可能有点令人迷惑的是，当你省略起始和结束索引时，Python竟然执行了正确的操作：步长为正数时，它从起点移到终点，而步长为负数时，它从终点移到起点。

::

    >>> numbers[0:10:-2]
    []

    >>> numbers[10:0:-2]
    [10, 8, 6, 4, 2]

    >>> numbers[::-2]
    [10, 8, 6, 4, 2]

    >>> numbers[5::-2]
    [6, 4, 2]

    >>> numbers[:5:-2]
    [10, 8]

序列相加
=======================

可使用加法运算符来拼接序列。但是不能拼接列表和字符串，虽然它们都是序列。一般而言，不能拼接不同类型的序列。

::

    >>> [1, 2, 3] + [4, 5, 6]
    [1, 2, 3, 4, 5, 6]

    >>> 'Hello,' + 'world!'
    'Hello, world!'

    >>> [1, 2, 3] + 'world!'
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: can only concatenate list (not "str") to list

乘法
=======================

将序列与数相乘时，将重复这个序列 n 次来创建一个新序列：

::

    >>> 'python' * 5
    'pythonpythonpythonpythonpython'

    >>> [42] * 10
    [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]

成员资格
=======================

要检查特定的值是否包含在序列中，可使用运算符 in 。它检查是否满足指定的条件，并返回相应的值：满足时返回 True，不满足时返回 False。下面是一些 in 运算符的使用示例：

::

    >>> permissions = 'rw'
    >>> 'w' in permissions
    True

    >>> 'x' in permissions
    False

    >>> subject = '$$$ Get rich now!!! $$$'
    >>> '$$$' in subject
    True
    >>> '$$ ' in subject
    True
    >>> ' $$ ' in subject
    False

相比于其他示例，检查字符串是否包含 $$$ 的示例稍有不同。一般而言，运算符 in 检查指定的对象是否是序列的成员（即其中的一个元素），但对字符串来说，只有它包含的字符才是其成员或元素，注意 $ 字符左右的空格。


长度、最小值和最大值
=======================

内置函数 len 返回序列包含的元素个数，而 min 和 max 分别返回序列中最小和最大的元素。

::

    >>> numbers = [100, 34, 678]
    >>> len(numbers)
    3
    >>> max(numbers)
    678
    >>> min(numbers)
    34
    >>> max(2, 3)
    3
    >>> min(9, 3, 2, 5)
    2

序列解包
=======================

一次给多个变量赋值的方法，称为序列解包，但是必须保证赋值运算符左右两边的元素数目相等。其形式如下：

::

    >>> a, b, c = 1, 2, 3
    >>> a
    1
    >>> b
    2
    >>> c
    3
    
序列解包还可以利用 ``*`` 表达式获取单个变量中的多个元素（获取的值默认为 list）。

::

    # 获取剩余部分：
    >>> a, b, *c = 0, 1, 2, 3
    >>> a
    0
    >>> b
    1
    >>> c
    [2, 3]

    # 获取中间部分：
    >>> a, *b, c = 0, 1, 2, 3
    >>> a
    0
    >>> b
    [1, 2]
    >>> c
    3

    # 如果左值比右值要多，那么带 * 的变量默认为空
    >>> a, b, *c = 0, 1
    >>> a
    0
    >>> b
    1
    >>> c
    []

    >>> a, *b, c = 0, 1
    >>> a
    0
    >>> b
    []
    >>> c
    1

    # 嵌套解包
    >>> (a, b), (c, d) = (1, 2), (3, 4)
    >>> a
    1
    >>> b
    2
    >>> c
    3
    >>> d
    4
    >>> a, b, c, d
    (1, 2, 3, 4)
